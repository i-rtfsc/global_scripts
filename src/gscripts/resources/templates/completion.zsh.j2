#compdef gs
# Global Scripts Zsh Completion - Dynamic router index support
# Auto-generated - All data dynamically loaded from router index
# Generated at: {{ timestamp }}

# Router index path for dynamic lookup
typeset -g _GS_ROUTER_INDEX="{{ router_index_path }}"
typeset -g _GS_LANGUAGE="{{ language }}"

# Helper function to get plugin names with descriptions
_gs_plugins() {
    local -a plugins descs
    if ! command -v jq &>/dev/null; then
        return
    fi

    # Get plugin names and descriptions
    local plugin_data=($(jq -r '.plugins | to_entries[] | "\(.key):\(.value.description.'$_GS_LANGUAGE' // .value.description.zh // .value.description.en // "")"' "$_GS_ROUTER_INDEX" 2>/dev/null))

    for item in ${plugin_data[@]}; do
        local name=$(echo "$item" | cut -d: -f1)
        local desc=$(echo "$item" | cut -d: -f2-)
        if [[ -n "$desc" ]]; then
            descs+=("$name:$desc")
        else
            descs+=("$name")
        fi
    done

    _describe 'plugins' descs
}

# Helper function to get subplugins/commands with descriptions
_gs_subplugins() {
    local plugin="${words[2]}"
    if [[ -z "$plugin" ]] || ! command -v jq &>/dev/null; then
        return
    fi

    local -a commands descs

    # Check if plugin has subplugins
    local subplugin_count=$(jq -r ".plugins[\"$plugin\"].subplugins | length" "$_GS_ROUTER_INDEX" 2>/dev/null)

    if [[ "$subplugin_count" != "null" && "$subplugin_count" != "0" ]]; then
        # Extract subplugins with descriptions
        local subplugin_data=($(jq -r ".plugins[\"$plugin\"].subplugins[] | \"\(.name):\(.description.$_GS_LANGUAGE // .description.zh // .description.en // \"\")\"" "$_GS_ROUTER_INDEX" 2>/dev/null))

        for item in ${subplugin_data[@]}; do
            local name=$(echo "$item" | cut -d: -f1)
            local desc=$(echo "$item" | cut -d: -f2-)
            if [[ -n "$desc" ]]; then
                descs+=("$name:$desc")
            else
                descs+=("$name")
            fi
        done
    else
        # No subplugins, extract first words from commands
        local -a cmd_list
        local -A seen_words

        # Read commands properly, preserving spaces
        while IFS= read -r cmd; do
            cmd_list+=("$cmd")
        done < <(jq -r ".plugins[\"$plugin\"].commands | keys[]" "$_GS_ROUTER_INDEX" 2>/dev/null)

        for cmd in "${cmd_list[@]}"; do
            local first_word=$(echo "$cmd" | awk '{print $1}')
            if [[ -z "${seen_words[$first_word]}" ]]; then
                seen_words[$first_word]=1
                local desc=$(jq -r ".plugins[\"$plugin\"].commands[\"$cmd\"].description.$_GS_LANGUAGE // .plugins[\"$plugin\"].commands[\"$cmd\"].description.zh // .plugins[\"$plugin\"].commands[\"$cmd\"].description.en // \"\"" "$_GS_ROUTER_INDEX" 2>/dev/null)
                if [[ -n "$desc" ]]; then
                    descs+=("$first_word:$desc")
                else
                    descs+=("$first_word")
                fi
            fi
        done
    fi

    _describe 'subplugins' descs
}

# Helper function to get functions with descriptions
_gs_functions() {
    local plugin="${words[2]}"
    local subplugin="${words[3]}"
    if [[ -z "$plugin" ]] || ! command -v jq &>/dev/null; then
        return
    fi

    local -a functions descs
    local cmd_prefix=""

    if [[ -n "$subplugin" ]]; then
        cmd_prefix="$subplugin "
    fi

    # Get all commands matching the prefix
    local -a cmd_list
    local -A seen_words

    # Read commands properly, preserving spaces
    while IFS= read -r cmd; do
        cmd_list+=("$cmd")
    done < <(jq -r ".plugins[\"$plugin\"].commands | keys[] | select(startswith(\"$cmd_prefix\"))" "$_GS_ROUTER_INDEX" 2>/dev/null)

    for cmd in "${cmd_list[@]}"; do
        # Extract the next word after prefix
        local remaining=$(echo "$cmd" | sed "s/^$cmd_prefix//")
        local next_word=$(echo "$remaining" | awk '{print $1}')

        if [[ -n "$next_word" && -z "${seen_words[$next_word]}" ]]; then
            seen_words[$next_word]=1
            local desc=$(jq -r ".plugins[\"$plugin\"].commands[\"$cmd\"].description.$_GS_LANGUAGE // .plugins[\"$plugin\"].commands[\"$cmd\"].description.zh // .plugins[\"$plugin\"].commands[\"$cmd\"].description.en // \"\"" "$_GS_ROUTER_INDEX" 2>/dev/null)
            if [[ -n "$desc" ]]; then
                descs+=("$next_word:$desc")
            else
                descs+=("$next_word")
            fi
        fi
    done

    _describe 'functions' descs
}

_gs_completions() {
    local cur prev
    cur="${words[$CURRENT]}"
    prev="${words[$CURRENT-1]}"

    # Handle option flags
    if [[ "$cur" == -* ]]; then
        _arguments \
            '--help[{{ help_desc }}]' \
            '--version[{{ version_desc }}]' \
            '--verbose[Enable verbose output]'
        return 0
    fi

    case $CURRENT in
        2)
            # First level: gs [command]
            local -a system_commands
            system_commands=(
                'help:{{ help_desc }}'
                'version:{{ version_desc }}'
                'plugin:{{ plugin_desc }}'
                'refresh:{{ refresh_desc }}'
                'status:{{ status_desc }}'
                'doctor:{{ doctor_desc }}'
                'parser:{{ parser_desc }}'
            )
            _describe 'system commands' system_commands
            _gs_plugins
            ;;
        3)
            # Second level: gs <plugin|system> [subcommand]
            case "$prev" in
                plugin)
                    local -a plugin_commands
                    plugin_commands=(
                        'list:List all plugins'
                        'info:Show plugin information'
                        'enable:Enable a plugin'
                        'disable:Disable a plugin'
                        'create:Create new plugin'
                    )
                    _describe 'plugin commands' plugin_commands
                    ;;
                parser)
                    local -a parser_commands
                    parser_commands=(
                        'list:List all parsers'
                        'info:Show parser information'
                        'enable:Enable a parser'
                        'disable:Disable a parser'
                        'test:Test file parsing'
                    )
                    _describe 'parser commands' parser_commands
                    ;;
                *)
                    _gs_subplugins
                    ;;
            esac
            ;;
        4)
            # Third level
            case "${words[2]}" in
                plugin)
                    case "${words[3]}" in
                        enable|disable|info)
                            _gs_plugins
                            ;;
                    esac
                    ;;
                parser)
                    case "${words[3]}" in
                        enable|disable|info)
                            # Get parser names from gs parser list
                            local -a parser_names
                            parser_names=($(gs parser list 2>/dev/null | grep -E '│.*│.*│.*│.*│' | grep -v '^┌' | grep -v '^├' | grep -v '^└' | grep -v 'Name' | awk -F'│' '{gsub(/^[ \t]+|[ \t]+$/, "", $2); print $2}'))
                            compadd -a parser_names
                            ;;
                    esac
                    ;;
                *)
                    _gs_functions
                    ;;
            esac
            ;;
        *)
            # Higher levels - continue with function completion
            _gs_functions
            ;;
    esac
}

compdef _gs_completions gs
