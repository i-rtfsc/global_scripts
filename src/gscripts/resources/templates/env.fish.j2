#!/usr/bin/env fish
# Global Scripts Environment Configuration (Fish Shell)
# Generated automatically - do not edit manually
# Generated at: {{ timestamp }}
# Configuration source: {{ source_dir }}

# Global Scripts root directory (absolute path)
set -gx GS_ROOT "{{ gs_root }}"

# Language setting - Controls UI language for all commands
set -gx GS_LANGUAGE "{{ language }}"

# Configuration Variables (from gs.json)
{% for key, value in config_exports.items() %}
set -gx GS_{{ key.upper() }} "{{ value }}"
{% endfor %}
set -gx GS_CONFIG_SHOW_EXAMPLES "{{ show_examples|lower }}"
set -gx GS_PROMPT_THEME "{{ prompt_theme }}"

# Add Global Scripts to PATH
# Prepend GS_ROOT to PATH if not present
if not contains $GS_ROOT $PATH
    set -gx PATH $GS_ROOT $PATH
end

# Global Scripts version
set -gx GS_VERSION "{{ version }}"

# Platform detection
set -gx GS_PLATFORM "{{ platform }}"

# Cache directory
set -gx GS_CACHE_DIR "{{ cache_dir }}"

# Load router script (if exists)
if test -r "$GS_ROOT/src/gscripts/scripts/gs-router.fish"
    source "$GS_ROOT/src/gscripts/scripts/gs-router.fish"
end

# Main gs() function with command routing
function gs --description "Global Scripts main command"
    set -l router_index "$GS_CACHE_DIR/router.json"

    # If no router index or jq not available, fall back to Python
    if not test -f "$router_index"; or not command -v jq >/dev/null 2>&1
        uv run --directory "$GS_ROOT" python -m gscripts.cli.main $argv
        return $status
    end

    # System commands always go to Python
    if test (count $argv) -eq 0; or contains -- $argv[1] help version plugin status doctor refresh
        uv run --directory "$GS_ROOT" python -m gscripts.cli.main $argv
        return $status
    end

    # Query router index to determine command type
    set -l plugin_name $argv[1]
    set -l query ""


    if test (count $argv) -eq 1
        set query $plugin_name
    else if test (count $argv) -eq 2
        set query $argv[2]
    else if test (count $argv) -ge 3
        # Try two-token form first
        set -l two_token "$argv[2] $argv[3]"
        set -l has_two_token (jq -r --arg plugin "$plugin_name" --arg query "$two_token" \
            ".plugins[\$plugin].commands[\$query] // empty" "$router_index" 2>/dev/null)


        if test -n "$has_two_token"
            set query "$two_token"
        else
            set query $argv[3]
        end
    end

    # Get command metadata
    set -l meta (jq -c --arg plugin "$plugin_name" --arg query "$query" \
        ".plugins[\$plugin].commands[\$query] // empty" "$router_index" 2>/dev/null)


    if test -z "$meta"; or test "$meta" = "null"
        # Command not found in router, fall back to Python
        uv run --directory "$GS_ROOT" python -m gscripts.cli.main $argv
        return $status
    end

    # Check if plugin is enabled
    set -l plugin_enabled (jq -r --arg plugin "$plugin_name" \
        '.plugins[$plugin].enabled' "$router_index" 2>/dev/null)

    if test -z "$plugin_enabled"; or test "$plugin_enabled" = "null"
        set plugin_enabled true
    end

    if test "$plugin_enabled" = "false"
        echo "错误: 插件 '$plugin_name' 已被禁用" >&2
        echo "提示: 使用 'gs plugin enable $plugin_name' 启用插件" >&2
        return 1
    end

    set -l kind (echo "$meta" | jq -r '.kind // "python"')

    # Route based on command type
    switch $kind
        case json
            # JSON commands: execute in current shell
            set -l command_tpl (echo "$meta" | jq -r '.command // empty')
            if test -z "$command_tpl"
                echo "Error: No command template defined for json type" >&2
                return 1
            end

            # Execute command (ensure cd/export take effect in current shell)
            if test (count $argv) -gt 2
                eval "$command_tpl" $argv[3..-1]
            else
                eval "$command_tpl"
            end
        case shell
            # Use shell router
            gs-router $argv
        case '*'
            # Use Python CLI (default)
            uv run --directory "$GS_ROOT" python -m gscripts.cli.main $argv
    end
end

# Quick reload alias
function gsreload --description "Reload Global Scripts environment"
    gs refresh >/dev/null 2>&1
    and source "$GS_ROOT/env.fish"
    and echo "✅ Global Scripts 环境已重新加载！"
end

# Initialize conda if available
if not command -v conda >/dev/null 2>&1
    for conda_base in "$HOME/miniconda3" "$HOME/anaconda3" "$HOME/miniforge3" \
                      "/opt/miniconda3" "/opt/anaconda3" "/opt/miniforge3" \
                      "/usr/local/miniconda3" "/usr/local/anaconda3"
        if test -f "$conda_base/etc/profile.d/conda.sh"
            bass source "$conda_base/etc/profile.d/conda.sh" 2>/dev/null
            break
        end
    end
end

# Load generated completion scripts
# Note: Completions are in parent of cache dir
set -l completions_dir (dirname "$GS_CACHE_DIR")/completions
if test -d "$completions_dir"
    for comp_file in $completions_dir/*.fish
        test -r "$comp_file"; and source "$comp_file"
    end
end

# Alias loading section
{% if aliases %}
# BEGIN aliases

{% for alias in aliases %}
# Plugin: {{ alias.name }}, Priority: {{ alias.priority }}
{% if alias.interactive_only %}
if status is-interactive
{% endif %}
{% for source in alias.sources %}
{% if 'darwin' in source.path.lower() %}
    # Load Darwin-specific aliases
    if test (uname -s) = "Darwin"
        # Try .fish first, fallback to bass + .sh
        if test -f {{ source.fish_path }}
            source {{ source.fish_path }}
        else if type -q bass; and test -f {{ source.sh_path }}
            bass source {{ source.sh_path }}
        end
    end
{% elif 'linux' in source.path.lower() %}
    # Load Linux-specific aliases
    if test (uname -s) = "Linux"
        # Try .fish first, fallback to bass + .sh
        if test -f {{ source.fish_path }}
            source {{ source.fish_path }}
        else if type -q bass; and test -f {{ source.sh_path }}
            bass source {{ source.sh_path }}
        end
    end
{% else %}
    # Load common aliases (hybrid: .fish or bass + .sh)
    if test -f {{ source.fish_path }}
        source {{ source.fish_path }}
    else if type -q bass; and test -f {{ source.sh_path }}
        bass source {{ source.sh_path }}
    end
{% endif %}
{% endfor %}
{% if alias.interactive_only %}
end
{% endif %}

{% endfor %}
# END aliases
{% endif %}
