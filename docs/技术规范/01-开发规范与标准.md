# Global Scripts V3 技术规范文档

## 📋 规范概述

本技术规范基于对项目深入分析和新架构设计，制定了完整的开发规范、代码标准和质量要求，确保项目代码的一致性、可维护性和高质量。

## 🎯 规范目标

### 核心目标
- **代码一致性**：统一的命名规范和编码风格
- **质量保证**：零警告、高覆盖率、完整测试
- **性能优化**：所有实现都考虑性能影响
- **开发效率**：降低学习成本，提高开发速度

### 质量标准
- **测试覆盖率**：≥90%（核心功能100%）
- **代码检查**：shellcheck零警告
- **文档完整性**：所有公开函数100%文档覆盖
- **性能要求**：启动时间<100ms，内存占用<10MB

## 🏗️ 插件开发规范

### 1. 目录结构规范

#### 标准插件结构
```bash
# 主插件目录结构（必须遵循）
plugins/{插件名}/
├── {插件名}.meta              # 插件元数据（必需）
├── {插件名}.sh                # 主插件实现（必需）
├── README.md                  # 插件说明文档（推荐）
├── tests/                     # 测试文件目录（推荐）
│   └── test_{插件名}.sh       # 插件测试文件
├── config/                    # 配置文件目录（可选）
│   └── default.conf          # 默认配置文件
└── {子模块名}/               # 子模块目录（可选）
    ├── {子模块名}.meta        # 子模块元数据
    ├── {子模块名}.sh          # 子模块实现
    └── tests/
        └── test_{子模块名}.sh  # 子模块测试

# 实际示例：Android插件
plugins/android/
├── android.meta
├── android.sh
├── README.md
├── tests/
│   └── test_android.sh
├── adb/
│   ├── adb.meta
│   ├── adb.sh
│   └── tests/
│       └── test_adb.sh
└── build/
    ├── build.meta
    ├── build.sh
    └── tests/
        └── test_build.sh
```

#### 系统命令结构
```bash
# 系统命令目录结构（特殊规范）
system/{命令名}/
├── {命令名}.meta             # 系统命令元数据
├── {命令名}.sh               # 系统命令实现
└── tests/
    └── test_{命令名}.sh       # 系统命令测试

# 实际示例：帮助系统
system/help/
├── help.meta
├── help.sh                   # gs_system_help()函数
└── tests/
    └── test_help.sh
```

### 2. .meta文件规范

#### 主插件.meta格式
```bash
# 必需字段（所有主插件都必须包含）
PLUGIN_TYPE=main
NAME={插件名}                  # 小写字母+下划线
VERSION={版本号}               # 语义化版本（如3.0.0）
DESCRIPTION={插件描述}         # 简洁明了的功能描述

# 推荐字段（建议包含）
AUTHOR={作者名}
HOMEPAGE={项目主页URL}
SYSTEM_DEPS={系统依赖}         # 逗号分隔，如：adb,fastboot
PLUGIN_DEPS={插件依赖}         # 逗号分隔，如：system,git
MIN_GS_VERSION={最小GS版本}    # 如：3.0.0
SUBMODULES={子模块列表}        # 逗号分隔，如：adb,build,frida

# 示例：Android插件.meta
PLUGIN_TYPE=main
NAME=android
VERSION=3.0.0
DESCRIPTION=Android开发工具集，提供ADB、编译、调试等功能
AUTHOR=Solo
HOMEPAGE=https://github.com/globalscripts/android-plugin
SYSTEM_DEPS=adb,fastboot,python3
PLUGIN_DEPS=system
MIN_GS_VERSION=3.0.0
SUBMODULES=adb,build,frida,push,grep
```

#### 子模块.meta格式
```bash
# 必需字段（所有子模块都必须包含）
PLUGIN_TYPE=submodule
NAME={子模块名}
PARENT={父插件名}
VERSION={版本号}               # 通常与父插件版本一致
DESCRIPTION={子模块描述}

# 可选字段
SYSTEM_DEPS={系统依赖}         # 子模块特有的系统依赖
PLUGIN_DEPS={插件依赖}         # 子模块特有的插件依赖

# 示例：ADB子模块.meta
PLUGIN_TYPE=submodule
NAME=adb
PARENT=android
VERSION=3.0.0
DESCRIPTION=Android Debug Bridge工具集
SYSTEM_DEPS=adb
```

#### 系统命令.meta格式
```bash
# 系统命令特殊格式
COMMAND_TYPE=system
NAME={命令名}
VERSION={版本号}
DESCRIPTION={命令描述}
AUTHOR=Global Scripts Team
SYSTEM_DEPS={系统依赖}         # 如果有的话
MIN_GS_VERSION=3.0.0

# 示例：帮助系统.meta
COMMAND_TYPE=system
NAME=help
VERSION=3.0.0
DESCRIPTION=Global Scripts帮助系统
AUTHOR=Global Scripts Team
SYSTEM_DEPS=
MIN_GS_VERSION=3.0.0
```

### 3. 函数命名规范

#### 命名约定规则
```bash
# 公开函数命名（自动生成命令）
格式：gs_{插件名}_{功能名}
生成：gs-{插件名}-{功能名}

# 命名要求：
- 插件名：小写字母+下划线，与目录名一致
- 功能名：小写字母+下划线，描述具体功能
- 总长度：建议不超过40个字符

# 正确示例
gs_android_device_list()        # → gs-android-device-list
gs_android_adb_shell()          # → gs-android-adb-shell
gs_git_branch_create()          # → gs-git-branch-create
gs_system_proxy_enable()       # → gs-system-proxy-enable

# 错误示例
android_device_list()           # ❌ 缺少gs_前缀
gs_Android_Device_List()        # ❌ 使用大写字母
gs_android-device-list()        # ❌ 使用连字符
gsAndroidDeviceList()          # ❌ 使用驼峰命名
```

#### 私有函数命名
```bash
# 私有函数命名（不生成命令）
格式：_gs_{插件名}_{功能名}

# 用途：
- 内部逻辑实现
- 参数验证函数
- 工具辅助函数
- 配置处理函数

# 正确示例
_gs_android_validate_device()   # 设备验证函数
_gs_git_check_repo()           # 仓库检查函数  
_gs_system_get_proxy_config()  # 获取代理配置
_gs_android_parse_logcat()     # 日志解析函数

# 命名原则：
- 必须以_gs_开头
- 功能描述清晰
- 与对应公开函数相关
```

#### 系统函数命名
```bash
# 系统函数命名（特殊规范）
格式：gs_system_{命令名}
生成：gs-{命令名}

# 示例
gs_system_help()               # → gs-help
gs_system_status()             # → gs-status
gs_system_version()            # → gs-version
gs_system_plugins()            # → gs-plugins

# 特点：
- 系统命令直接使用gs-前缀
- 不包含system关键词
- 保持简洁性
```

### 4. 变量命名规范

#### 全局变量命名
```bash
# 全局常量（只读变量）
格式：_GS_{模块名}_{变量名}

# 示例
readonly _GS_ANDROID_SDK_PATH="/path/to/sdk"
readonly _GS_CONFIG_DIR="/path/to/config"
readonly _GS_CACHE_MAX_SIZE=1000
readonly _GS_DEBUG_MODE=false

# 要求：
- 使用readonly声明
- 全大写字母+下划线
- _GS_前缀避免冲突
- 有意义的名称
```

#### 局部变量命名
```bash
# 函数内局部变量
格式：{描述性名称}

# 示例
local device_id="$1"
local config_file="/tmp/config"
local is_valid=false
local user_input=""
local error_message=""

# 要求：
- 使用local声明
- 小写字母+下划线
- 描述性强
- 避免缩写
```

#### 环境变量命名
```bash
# 用户可配置的环境变量
格式：GS_{功能域}_{变量名}

# 示例
export GS_ANDROID_SDK_PATH="/path/to/sdk"
export GS_DEBUG_MODE=false
export GS_LOG_LEVEL=INFO
export GS_CACHE_ENABLED=true

# 要求：
- GS_前缀
- 全大写字母+下划线
- 用户友好的名称
- 提供默认值
```

## 📝 代码编写规范

### 1. 函数结构模板

#### 完整函数模板
```bash
#!/bin/bash
# Global Scripts V3 - {插件名} 插件
# 作者: {作者名}
# 版本: {版本号}
# 描述: {插件描述}

# 加载控制机制（使用lib/base.sh替代readonly）
source "${GS_ROOT}/lib/base.sh"

# 防止重复加载（除非强制重新加载）
if _gs_is_constant "_GS_{插件名大写}_LOADED" && [[ "${GS_FORCE_RELOAD:-false}" != "true" ]]; then
    return 0
fi
_gs_set_constant "_GS_{插件名大写}_LOADED" "true"

# 私有函数示例
_gs_{插件名}_validate_input() {
    # 功能描述: 验证输入参数的有效性
    # 参数: $1 - 输入参数 (字符串): 需要验证的参数
    # 返回值: 0 - 验证成功, 1 - 验证失败
    # 依赖: 无
    
    local input="$1"
    
    # 参数存在性检查
    [[ -n "$input" ]] || {
        echo "错误: 输入参数不能为空" >&2
        return 1
    }
    
    # 参数格式检查（示例）
    [[ "$input" =~ ^[a-zA-Z0-9_-]+$ ]] || {
        echo "错误: 参数格式无效，只能包含字母、数字、下划线和连字符" >&2
        return 1
    }
    
    return 0
}

# 公开函数示例（完整版本）
gs_{插件名}_{功能名}() {
    # 功能描述: 详细说明函数的作用和用途
    # 
    # 参数:
    #   $1 - 参数名 (类型): 参数详细描述 [必需/可选]
    #   $2 - 参数名 (类型): 参数详细描述 [可选]
    # 
    # 返回值:
    #   0 - 执行成功
    #   1 - 参数错误
    #   2 - 执行失败
    #   3 - 权限错误
    # 
    # 示例:
    #   gs-{插件名}-{功能名} param1 param2
    #   gs-{插件名}-{功能名} --help
    # 
    # 依赖:
    #   系统命令: command1, command2
    #   插件依赖: plugin1, plugin2
    
    local param1="${1:-}"
    local param2="${2:-}"
    
    # 1. 帮助信息处理（必需）
    if [[ "$param1" == "--help" || "$param1" == "-h" ]]; then
        _show_{插件名}_{功能名}_help
        return 0
    fi
    
    # 2. 参数数量检查（必需）
    if [[ $# -eq 0 ]]; then
        echo "错误: 缺少必需参数" >&2
        echo "使用方式: gs-{插件名}-{功能名} <参数1> [参数2]" >&2
        echo "使用 'gs-{插件名}-{功能名} --help' 查看详细帮助" >&2
        return 1
    fi
    
    # 3. 参数验证（必需）
    _gs_{插件名}_validate_input "$param1" || return 1
    
    # 4. 环境依赖检查（推荐）
    if ! command -v required_command >/dev/null 2>&1; then
        echo "错误: 缺少必需命令: required_command" >&2
        echo "建议: 请安装相应的软件包" >&2
        return 2
    fi
    
    # 5. 核心功能实现
    echo "执行功能: $param1"
    
    # 6. 错误处理示例
    if ! some_command "$param1"; then
        echo "错误: 命令执行失败" >&2
        echo "建议: 检查参数是否正确或权限是否足够" >&2
        return 2
    fi
    
    # 7. 成功返回
    echo "功能执行成功"
    return 0
}

# 帮助信息函数（必需）
_show_{插件名}_{功能名}_help() {
    cat << 'EOF'
gs_{插件名}_{功能名} - 功能简要描述

功能描述:
  详细的功能说明，包括用途、行为和效果

使用方式:
  gs-{插件名}-{功能名} <参数1> [参数2] [选项]

参数:
  参数1          参数描述（必需）
  参数2          参数描述（可选）

选项:
  --help, -h     显示此帮助信息

示例:
  gs-{插件名}-{功能名} example_value
  gs-{插件名}-{功能名} value1 value2
  gs-{插件名}-{功能名} --help

依赖:
  系统命令: command1, command2
  插件依赖: plugin1, plugin2

注意事项:
  - 重要的使用注意事项
  - 可能的副作用说明
  - 相关的安全考虑
EOF
}
```

### 2. 错误处理规范

#### 错误码标准
```bash
# 标准错误码定义
readonly _GS_SUCCESS=0           # 执行成功
readonly _GS_PARAM_ERROR=1       # 参数错误
readonly _GS_FILE_ERROR=2        # 文件错误
readonly _GS_COMMAND_ERROR=3     # 命令执行错误
readonly _GS_PERMISSION_ERROR=4  # 权限错误
readonly _GS_NETWORK_ERROR=5     # 网络错误
readonly _GS_CONFIG_ERROR=6      # 配置错误
readonly _GS_DEPENDENCY_ERROR=7  # 依赖错误

# 函数别名生成（使用alias替代eval，提高兼容性）
_gs_register_plugin_functions() {
    local plugin_name="$1"
    local before_functions="$2"
    
    # 获取当前所有函数
    local current_functions
    current_functions=$(_gs_scan_functions)
    
    # 找出新增的函数
    local new_functions
    if [[ -n "$before_functions" ]]; then
        new_functions=$(comm -13 <(echo "$before_functions" | sort) <(echo "$current_functions" | sort))
    else
        new_functions="$current_functions"
    fi
    
    # 只注册属于当前插件的新函数
    while IFS= read -r func_name; do
        [[ -z "$func_name" ]] && continue
        
        # 检查是否为公开的插件函数（排除私有函数）
        if [[ "$func_name" =~ ^gs_[a-zA-Z0-9_]+$ ]] && [[ ! "$func_name" =~ ^_gs_ ]]; then
            # 检查是否属于当前插件
            if [[ "$func_name" =~ ^gs_${plugin_name}_[a-zA-Z0-9_]+$ ]] || \
               [[ "$func_name" =~ ^gs_${plugin_name}$ ]]; then
                
                # 生成命令别名
                local cmd_name="${func_name//gs_/gs-}"
                cmd_name="${cmd_name//_/-}"
                
                # 使用alias创建命令别名（兼容性更好，避免eval问题）
                alias "$cmd_name"="$func_name"
                
                # 记录到注册表
                _gs_register_command "$cmd_name" "$func_name" "plugin" "$plugin_name"
            fi
        fi
    done <<< "$new_functions"
# 使用示例（基于lib/base.sh的常量机制）
gs_example_function() {
    local file_path="$1"
    
    # 参数检查
    [[ -n "$file_path" ]] || {
        echo "错误: 文件路径不能为空" >&2
        return $_GS_PARAM_ERROR
    }
    
    # 文件存在性检查
    [[ -f "$file_path" ]] || {
        echo "错误: 文件不存在: $file_path" >&2
        echo "建议: 检查文件路径是否正确" >&2
        return $_GS_FILE_ERROR
    }
    
    # 权限检查
    [[ -r "$file_path" ]] || {
        echo "错误: 文件无读权限: $file_path" >&2
        echo "建议: 使用 chmod +r '$file_path' 或 sudo" >&2
        return $_GS_PERMISSION_ERROR
    }
    
    return $_GS_SUCCESS
}
}
```

#### 友好错误信息格式
```bash
# 错误信息标准格式
show_friendly_error() {
    local error_type="$1"
    local context="$2"
    local suggestion="$3"
    
    echo "错误: $error_type" >&2
    [[ -n "$context" ]] && echo "详情: $context" >&2
    [[ -n "$suggestion" ]] && echo "建议: $suggestion" >&2
    echo "帮助: 使用 --help 查看详细使用说明" >&2
}

# 使用示例
if ! validate_device_id "$device_id"; then
    show_friendly_error \
        "设备ID无效" \
        "设备ID '$device_id' 不符合预期格式" \
        "使用 'gs-android-device-list' 查看可用设备"
    return $_GS_PARAM_ERROR
fi
```

### 3. 日志输出规范

#### 日志级别定义
```bash
# 日志级别常量
readonly _GS_LOG_ERROR=1
readonly _GS_LOG_WARN=2
readonly _GS_LOG_INFO=3
readonly _GS_LOG_DEBUG=4

# 日志函数（如果可用，使用统一日志系统）
_gs_log() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # 检查是否有统一日志系统可用
    if declare -F "_gs_logger_log" >/dev/null 2>&1; then
        _gs_logger_log "$level" "$message"
        return
    fi
    
    # 备选：直接输出
    case "$level" in
        "$_GS_LOG_ERROR")
            echo "[$timestamp] ERROR: $message" >&2
            ;;
        "$_GS_LOG_WARN")
            echo "[$timestamp] WARN: $message" >&2
            ;;
        "$_GS_LOG_INFO")
            echo "[$timestamp] INFO: $message"
            ;;
        "$_GS_LOG_DEBUG")
            [[ "${GS_DEBUG_MODE:-false}" == "true" ]] && \
            echo "[$timestamp] DEBUG: $message"
            ;;
    esac
}

# 使用示例
gs_example_with_logging() {
    _gs_log "$_GS_LOG_INFO" "开始执行示例功能"
    
    if ! some_operation; then
        _gs_log "$_GS_LOG_ERROR" "操作执行失败"
        return 1
    fi
    
    _gs_log "$_GS_LOG_INFO" "示例功能执行成功"
    return 0
}
```

### 4. 性能编码规范

#### 性能最佳实践
```bash
# 1. 避免不必要的子进程创建
# ❌ 错误方式
result=$(echo "$string" | grep "pattern")

# ✅ 正确方式  
[[ "$string" =~ pattern ]]

# 2. 使用内置命令替代外部工具
# ❌ 错误方式
length=$(echo "$string" | wc -c)

# ✅ 正确方式
length=${#string}

# 3. 避免重复的命令调用
# ❌ 错误方式
if command -v tool >/dev/null 2>&1; then
    result1=$(tool --option1)
fi
if command -v tool >/dev/null 2>&1; then
    result2=$(tool --option2)
fi

# ✅ 正确方式
if tool_path=$(command -v tool 2>/dev/null); then
    result1=$("$tool_path" --option1)
    result2=$("$tool_path" --option2)
fi

# 4. 使用数组替代多次字符串拼接
# ❌ 错误方式
result=""
for item in "${items[@]}"; do
    result="$result,$item"
done

# ✅ 正确方式
result_array=()
for item in "${items[@]}"; do
    result_array+=("$item")
done
result=$(IFS=','; echo "${result_array[*]}")

# 5. 缓存重复计算结果
# ❌ 错误方式
for file in "${files[@]}"; do
    if [[ $(date -r "$file" +%s) -gt $(date -d "1 hour ago" +%s) ]]; then
        process_file "$file"
    fi
done

# ✅ 正确方式
cutoff_time=$(date -d "1 hour ago" +%s)
for file in "${files[@]}"; do
    if [[ $(date -r "$file" +%s) -gt $cutoff_time ]]; then
        process_file "$file"
    fi
done
```

## 🧪 测试规范

### 1. 测试文件结构

#### 测试文件命名和位置
```bash
# 测试文件命名规范
格式：test_{插件名}.sh （主插件测试）
     test_{子模块名}.sh （子模块测试）

# 测试文件位置
plugins/{插件名}/tests/test_{插件名}.sh
plugins/{插件名}/{子模块名}/tests/test_{子模块名}.sh
system/{命令名}/tests/test_{命令名}.sh

# 测试文件结构模板
#!/bin/bash
# Global Scripts V3 - {插件名} 插件测试
# 作者: {作者名}
# 版本: {版本号}

# 加载测试框架
source "${GS_ROOT}/tests/test_framework.sh" || {
    echo "❌ 无法加载测试框架" >&2
    exit 1
}

# 加载被测试的插件
source "${GS_ROOT}/plugins/{插件名}/{插件名}.sh" || {
    echo "❌ 无法加载插件: {插件名}" >&2
    exit 1
}

# 测试环境设置
setup_test() {
    # 创建测试所需的临时文件和目录
    mkdir -p "$TEST_TEMP_DIR"
    
    # 设置测试环境变量
    export TEST_MODE=true
    
    # 准备测试数据
    echo "test data" > "$TEST_TEMP_DIR/test_file.txt"
}

# 测试环境清理
teardown_test() {
    # 清理临时文件和目录
    rm -rf "$TEST_TEMP_DIR"
    
    # 恢复环境变量
    unset TEST_MODE
}

# 测试用例：基本功能测试
test_gs_{插件名}_{功能名}_basic() {
    # 测试描述
    local test_description="测试基本功能执行"
    
    # 准备测试数据
    local test_input="test_value"
    local expected_output="expected result"
    
    # 执行被测试函数
    local actual_output
    actual_output=$(gs_{插件名}_{功能名} "$test_input")
    local exit_code=$?
    
    # 断言检查
    assert_equals 0 "$exit_code" "函数应该成功执行"
    assert_contains "$actual_output" "$expected_output" "输出应该包含期望内容"
    
    # 记录测试结果
    log_test_result "$test_description" "PASS"
}

# 测试用例：错误处理测试
test_gs_{插件名}_{功能名}_error_handling() {
    local test_description="测试错误处理机制"
    
    # 测试空参数
    gs_{插件名}_{功能名} "" 2>/dev/null
    local exit_code=$?
    assert_equals 1 "$exit_code" "空参数应该返回错误码1"
    
    # 测试无效参数
    gs_{插件名}_{功能名} "invalid_parameter" 2>/dev/null
    local exit_code=$?
    assert_equals 1 "$exit_code" "无效参数应该返回错误码1"
    
    log_test_result "$test_description" "PASS"
}

# 测试用例：帮助信息测试
test_gs_{插件名}_{功能名}_help() {
    local test_description="测试帮助信息显示"
    
    # 测试--help选项
    local help_output
    help_output=$(gs_{插件名}_{功能名} --help)
    local exit_code=$?
    
    assert_equals 0 "$exit_code" "帮助命令应该成功执行"
    assert_contains "$help_output" "功能描述" "帮助信息应该包含功能描述"
    assert_contains "$help_output" "使用方式" "帮助信息应该包含使用方式"
    assert_contains "$help_output" "示例" "帮助信息应该包含使用示例"
    
    log_test_result "$test_description" "PASS"
}

# 运行测试套件
run_test_suite "{插件名}插件测试" setup_test teardown_test
```

### 2. 测试覆盖要求

#### 必须测试的场景
```bash
# 测试覆盖清单
test_coverage_checklist=(
    "✅ 正常功能测试 - 验证基本功能正确性"
    "✅ 参数验证测试 - 测试各种参数组合"
    "✅ 错误处理测试 - 测试异常情况处理"
    "✅ 边界条件测试 - 测试极限和边界值"
    "✅ 帮助信息测试 - 验证--help选项"
    "✅ 依赖检查测试 - 测试系统依赖验证"
    "✅ 权限测试 - 测试文件和系统权限"
    "✅ 配置测试 - 测试配置文件处理"
    "✅ 性能测试 - 验证性能要求"
    "✅ 兼容性测试 - 测试多平台兼容性"
)

# 覆盖率要求
# - 公开函数（gs_*）：100%覆盖
# - 私有函数（_gs_*）：90%+覆盖
# - 错误处理路径：100%覆盖
# - 帮助信息：100%覆盖
```

#### 测试断言函数
```bash
# 标准断言函数（测试框架提供）
assert_equals() {
    local expected="$1"
    local actual="$2" 
    local message="$3"
    
    if [[ "$expected" != "$actual" ]]; then
        echo "❌ 断言失败: $message" >&2
        echo "   期望值: '$expected'" >&2
        echo "   实际值: '$actual'" >&2
        return 1
    fi
    return 0
}

assert_contains() {
    local haystack="$1"
    local needle="$2"
    local message="$3"
    
    if [[ "$haystack" != *"$needle"* ]]; then
        echo "❌ 断言失败: $message" >&2
        echo "   字符串: '$haystack'" >&2
        echo "   不包含: '$needle'" >&2
        return 1
    fi
    return 0
}

assert_file_exists() {
    local file_path="$1"
    local message="$2"
    
    if [[ ! -f "$file_path" ]]; then
        echo "❌ 断言失败: $message" >&2
        echo "   文件不存在: '$file_path'" >&2
        return 1
    fi
    return 0
}

assert_command_success() {
    local command="$1"
    local message="$2"
    
    if ! $command >/dev/null 2>&1; then
        echo "❌ 断言失败: $message" >&2
        echo "   命令失败: '$command'" >&2
        return 1
    fi
    return 0
}
```

## 📚 文档规范

### 1. 函数文档规范

#### 文档模板
```bash
# 函数文档标准格式
function_name() {
    # 功能描述: 一句话概括函数的主要功能
    # 
    # 详细说明:
    #   更详细的功能说明，包括：
    #   - 函数的具体行为
    #   - 副作用说明
    #   - 特殊情况处理
    # 
    # 参数:
    #   $1 - 参数名 (类型): 参数详细描述 [必需/可选]
    #   $2 - 参数名 (类型): 参数详细描述 [可选]
    #   $3 - 选项 (字符串): 可选的配置选项，如--help [可选]
    # 
    # 返回值:
    #   0 - 执行成功
    #   1 - 参数错误或输入无效
    #   2 - 执行失败或操作不成功
    #   3 - 权限不足或访问被拒绝
    #   4 - 资源不可用或依赖缺失
    # 
    # 示例:
    #   function_name param1 param2
    #   function_name param1 --help
    #   function_name "complex param" optional_param
    # 
    # 依赖:
    #   系统命令: command1, command2, command3
    #   插件依赖: plugin1, plugin2
    #   环境变量: ENV_VAR1, ENV_VAR2
    # 
    # 注意事项:
    #   - 重要的使用注意事项
    #   - 可能的副作用
    #   - 安全考虑
    #   - 性能影响
    
    # 函数实现...
}
```

### 2. README.md规范

#### 插件README模板
```markdown
# {插件名} 插件

## 概述
简要描述插件的主要功能和用途。

## 功能特性
- 功能1：具体描述
- 功能2：具体描述  
- 功能3：具体描述

## 安装要求

### 系统依赖
- 依赖1：版本要求
- 依赖2：版本要求

### 插件依赖
- 插件1：版本要求
- 插件2：版本要求

## 使用方法

### 基本命令
- `gs-{插件名}-{功能1}`: 功能1描述
- `gs-{插件名}-{功能2}`: 功能2描述

### 使用示例
```bash
# 示例1：基本用法
gs-{插件名}-{功能1} 参数

# 示例2：高级用法
gs-{插件名}-{功能2} --option value

# 示例3：帮助信息
gs-{插件名}-{功能1} --help
```

## 配置选项
| 环境变量 | 默认值 | 描述 |
|---------|--------|------|
| GS_{插件名大写}_OPTION1 | default1 | 选项1描述 |
| GS_{插件名大写}_OPTION2 | default2 | 选项2描述 |

## 故障排除

### 常见问题
1. **问题1描述**
   - 原因：问题原因分析
   - 解决方案：具体解决步骤

2. **问题2描述**
   - 原因：问题原因分析
   - 解决方案：具体解决步骤

### 调试方法
```bash
# 启用调试模式
export GS_DEBUG_MODE=true
export GS_PLUGIN_DEBUG={插件名}

# 查看详细日志
gs-{插件名}-{功能} 参数 2>&1 | grep DEBUG
```

## 开发指南
如果其他开发者想要扩展或修改此插件，请参阅：
- 函数命名规范
- 错误处理标准
- 测试要求
- 文档更新要求

## 版本历史
- v3.0.0: 初始版本，基础功能实现
- v3.0.1: 修复了XXX问题，增加了XXX功能

## 许可证
遵循Global Scripts项目的开源许可证。

## 贡献
欢迎提交Issue和Pull Request。
```

## 🔍 代码审查规范

### 代码审查清单
```bash
# 代码审查检查项目
code_review_checklist=(
    "✅ 函数命名符合规范（gs_/_ gs_前缀）"
    "✅ 变量命名清晰有意义"
    "✅ 参数验证完整"
    "✅ 错误处理完善"
    "✅ 帮助信息完整"
    "✅ 函数文档完整"
    "✅ 性能考虑合理"
    "✅ 安全性检查通过"
    "✅ 测试覆盖充分"
    "✅ shellcheck检查通过"
    "✅ 兼容性考虑"
    "✅ 代码风格一致"
)

# 审查标准
review_standards=(
    "功能正确性：代码实现与需求一致"
    "代码质量：结构清晰，逻辑合理"
    "性能影响：不能显著影响系统性能"
    "安全考虑：无安全漏洞和风险"
    "可维护性：代码易于理解和维护"
    "测试完整：测试覆盖率满足要求"
    "文档同步：文档与代码保持一致"
)
```

## 🎯 质量保证

### 自动化检查
```bash
# 提交前自动检查脚本
pre_commit_check() {
    echo "🔍 执行提交前代码检查..."
    
    # 1. shellcheck检查
    echo "1. 运行shellcheck检查..."
    if ! find . -name "*.sh" -exec shellcheck {} \;; then
        echo "❌ shellcheck检查失败"
        return 1
    fi
    
    # 2. 插件规范检查
    echo "2. 运行插件规范检查..."
    if ! gs-plugin-lint plugins/; then
        echo "❌ 插件规范检查失败"  
        return 1
    fi
    
    # 3. 测试执行
    echo "3. 运行测试套件..."
    if ! tests/test_runner.sh; then
        echo "❌ 测试执行失败"
        return 1
    fi
    
    # 4. 性能回归检查
    echo "4. 运行性能回归检查..."
    if ! tests/performance_test.sh; then
        echo "❌ 性能回归检查失败"
        return 1
    fi
    
    echo "✅ 所有检查通过，可以提交代码"
    return 0
}
```

### 质量指标
- **代码覆盖率**：≥90%（核心功能100%）
- **shellcheck检查**：零警告
- **性能指标**：不能超过基线10%
- **文档覆盖**：所有公开函数100%
- **测试成功率**：100%

这个技术规范确保了Global Scripts V3项目的代码质量、一致性和可维护性，为项目的成功提供了坚实的技术基础。