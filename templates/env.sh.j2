#!/bin/bash
# Global Scripts V6 Environment Configuration
# Generated automatically - do not edit manually
# Generated at: {{ timestamp }}
# Configuration source: {{ source_dir }}

# Global Scripts root directory (absolute path)
export GS_ROOT="{{ gs_root }}"

# Language setting - Controls UI language for all commands
export GS_LANGUAGE="{{ language }}"

# V6 Configuration Variables (from gs.json)
{% for key, value in config_exports.items() %}
export GS_{{ key.upper() }}="{{ value }}"
{% endfor %}
export GS_CONFIG_SHOW_EXAMPLES="{{ show_examples|lower }}"
export GS_PROMPT_THEME="{{ prompt_theme }}"

# Add Global Scripts to PATH
# Prepend GS_ROOT to PATH if not present
case ":$PATH:" in
    *":$GS_ROOT:"*) ;;
    *) export PATH="$GS_ROOT:$PATH" ;;
esac

# Global Scripts version
export GS_VERSION="{{ version }}"

# Platform detection
export GS_PLATFORM="{{ platform }}"

# Cache directory
export GS_CACHE_DIR="{{ cache_dir }}"

# Router index path
export ROUTER_INDEX="$GS_CACHE_DIR/router.json"

# Plugin command functions with performance optimization

# Load prompt theme (interactive shells only)
if [[ $- == *i* ]]; then
    if [[ -r "$GS_ROOT/themes/prompt/load.sh" ]]; then
        source "$GS_ROOT/themes/prompt/load.sh"
    fi
fi

{% include 'gs_function.sh.j2' %}

# Quick reload alias (rebuild completions, then reload env without rewriting env.sh)
alias gsreload='gs refresh >/dev/null 2>&1; source "$GS_ROOT/env.sh" && echo "✅ Global Scripts 环境已重新加载！"'

# Initialize conda if available (lightweight detection)
if ! command -v conda >/dev/null 2>&1; then
    for conda_base in "$HOME/miniconda3" "$HOME/anaconda3" "$HOME/miniforge3" \
                      "/opt/miniconda3" "/opt/anaconda3" "/opt/miniforge3" \
                      "/usr/local/miniconda3" "/usr/local/anaconda3"; do
        if [[ -f "$conda_base/etc/profile.d/conda.sh" ]]; then
            source "$conda_base/etc/profile.d/conda.sh" 2>/dev/null
            break
        fi
    done
fi

# Zsh completion system init (safe, no-op if already)
if [[ -n "$ZSH_VERSION" ]]; then
    autoload -U compinit
    compinit -u
fi

# Load generated completion scripts
if [[ -d "$GS_CACHE_DIR/completions" ]]; then
    if [[ -n "$ZSH_VERSION" ]]; then
        for comp_file in "$GS_CACHE_DIR/completions"/*.zsh; do
            [[ -r "$comp_file" ]] && source "$comp_file"
        done
    elif [[ -n "$BASH_VERSION" ]]; then
        for comp_file in "$GS_CACHE_DIR/completions"/*.bash; do
            [[ -r "$comp_file" ]] && source "$comp_file"
        done
    else
        for comp_file in "$GS_CACHE_DIR/completions"/*; do
            [[ -r "$comp_file" ]] && source "$comp_file"
        done
    fi
fi

# Alias loading section
{% if aliases %}
# BEGIN aliases
# Detect interactive shell for conditional loading
__GS_ALIAS_IS_INTERACTIVE=0
case $- in *i*) __GS_ALIAS_IS_INTERACTIVE=1 ;; esac

{% for alias in aliases %}
# Plugin: {{ alias.name }}, Priority: {{ alias.priority }}
# Shells: {{ alias.shells|join(' ') }}, Interactive only: {{ alias.interactive_only }}
{% if alias.shell_check %}
if {{ alias.shell_check }}; then
{% endif %}
{% if alias.interactive_only %}
    if [ "$__GS_ALIAS_IS_INTERACTIVE" = "1" ]; then
{% endif %}
{% for source in alias.sources %}
{% if 'darwin' in source.path.lower() %}
        # Load Darwin-specific aliases
        if [ "$(uname -s)" = "Darwin" ]; then
            [ -f "{{ source.full_path }}" ] && . "{{ source.full_path }}"
        fi
{% elif 'linux' in source.path.lower() %}
        # Load Linux-specific aliases
        if [ "$(uname -s)" = "Linux" ]; then
            [ -f "{{ source.full_path }}" ] && . "{{ source.full_path }}"
        fi
{% else %}
        # Load common aliases
        [ -f "{{ source.full_path }}" ] && . "{{ source.full_path }}"
{% endif %}
{% endfor %}
{% if alias.interactive_only %}
    fi
{% endif %}
{% if alias.shell_check %}
fi
{% endif %}

{% endfor %}
# Cleanup alias loading variables
unset __GS_ALIAS_IS_INTERACTIVE
# END aliases
{% endif %}
